您好，欢迎来到 WWDC。
 大家好，我是本。
  我是语言和运行时团队的一员，我将与您讨论我们今年在 iOS 和 mac OS 中的 Objective-C 运行时所做的更改，这些更改显着改善了内存使用。
  这个演讲与大多数人有点不同。
  您不需要更改任何代码。
  我不会谈论今年要学习的任何新 API 或对压缩的弃用警告。
  运气好的话，你不需要做任何事情，你的应用程序会变得更快。
  我们为什么要告诉您这些改进？ 嗯，部分是因为我们认为它们很酷很有趣，还因为运行时的这些改进只有在我们的内部数据结构隐藏在 API 之后才有可能实现。
  当应用程序直接访问这些数据结构时，事情会变得有些混乱。
 在本次演讲中，您将了解一些需要注意的事情，当其他人（显然不是您）访问他们不应该访问的内容时，可能会发生这种情况。
  我们将在本次会议中介绍三个变化。
  首先，Objective-C 运行时用来跟踪类的数据结构发生了变化。
 然后我们将看看 Objective-C 方法列表的变化。
 最后，我们将看看标记指针表示方式的变化。
 因此，让我们从更改类的运行时数据开始。
  在磁盘上，在您的应用程序二进制文件中，类看起来像这样。
 首先是类对象本身，它包含最常访问的信息：指向元类、超类和方法缓存的指针。
 它还具有指向存储附加信息的更多数据的指针，称为 class_ro_t。
  “Ro”代表只读。
  这包括类的名称以及有关方法、协议和实例变量的信息。
 Swift 类和 Objective-C 类共享此基础结构，因此每个 Swift 类也具有这些数据结构。
 当类第一次从磁盘加载到内存中时，它们也是这样开始的，但是一旦使用它们就会改变。
  现在，要了解接下来会发生什么，了解干净内存和脏内存之间的区别很有用。
 干净的内存是一旦加载就不会改变的内存。
 class_ro_t 是干净的，因为它是只读的。
 脏内存是在进程运行时改变的内存。
 一旦类被使用，类结构就会变脏，因为运行时将新数据写入其中。
  例如，它创建一个新的方法缓存并从类中指向它。
 脏内存比干净内存贵得多。
  只要进程在运行，它就必须一直存在。
 另一方面，干净的内存可以被逐出为其他东西腾出空间，因为如果你需要它，系统总是可以从磁盘重新加载它。
 macOS 可以选择换出脏内存，但脏内存在 iOS 中的开销特别大，因为它不使用交换。
 脏内存是这个类数据被拆分成两块的原因。
 可以保持清洁的数据越多越好。
  通过分离出永远不会改变的数据，可以将大部分类数据保留为干净的内存。
 这些数据足以让我们开始，但运行时需要跟踪有关每个类的更多信息。
  因此，当一个类第一次被使用时，运行时会为其分配额外的存储空间。
 这个运行时分配的存储是 class_rw_t，用于读/写数据。
  在这个数据结构中，我们存储仅在运行时生成的新信息。
 例如，使用这些 First Subclass 和 Next Sibling Class 指针将所有类链接到树结构中，这允许运行时遍历当前使用的所有类，这对于使方法缓存无效很有用。
 但是为什么我们这里有方法和属性，而它们也在只读数据中呢？ 嗯，因为它们可以在运行时更改。
  加载类别时，它可以向类添加新方法，程序员可以使用运行时 API 动态添加它们。
 由于 class_ro_t 是只读的，我们需要在 class_rw_t 中跟踪这些东西。
 现在，事实证明这占用了相当多的内存。
  在任何给定的设备中都有很多类正在使用。
  我们在 iPhone 的整个系统中测量了大约 30 MB 的这些 class_rw_t 结构。
 那么，我们怎样才能缩小这些呢？ 请记住，我们在读/写部分需要这些东西，因为它们可以在运行时更改。
 但是检查在真实设备上的使用情况，我们发现只有大约 10% 的类实际上改变了它们的方法。
 并且这个 demangled name 字段只被 Swift 类使用，甚至不需要 Swift 类，除非有什么要求他们的 Objective-C 名称。
 因此，我们可以将不常用的部分拆分出来，这样可以将 class_rw_t 的大小减少一半。
 对于确实需要附加信息的类，我们可以分配这些扩展记录之一并将其滑入以供类使用。
 大约 90% 的类从不需要这些扩展数据，节省了大约 14 兆字节的系统宽度。
  这是现在可用于更高效用途的内存，例如存储应用程序的数据。
  因此，您实际上可以通过在终端中运行一些简单的命令来亲自查看此更改对 Mac 的影响。
  现在让我们来看看。
  我要在我的 MacBook 上进入终端，然后我要运行一个在任何 Mac 上都可用的命令，称为 heap。
  它允许您检查正在运行的进程正在使用的堆内存。
  所以，我要在 Mac 上的邮件应用程序上运行它。
  现在，如果我只是运行它，它会输出数千行，显示 Mail 所做的每个堆分配。
  所以，相反，我只是针对我们今天讨论的类型进行 grep。
 class_rw_t 类型。
  我还要搜索标题。
 从返回的结果中，我们可以看到我们在邮件应用程序中使用了大约 9000 个这些 class_rw_t 类型，但只有大约十分之一，略高于 900，实际上需要这些扩展信息。
  因此，我们可以轻松计算出此更改为我们节省的费用。
 这是尺寸减半的类型。
  所以，如果我们从这个数字中减去我们必须分配给扩展类型的内存量，我们可以看到我们已经为邮件应用程序节省了大约四分之一兆的数据。
  如果我们在整个系统范围内扩展该系统，那么就脏内存而言，这是一个真正的节省。
 现在，许多从类中获取数据的代码现在必须处理有和没有这些扩展数据的类。
  当然，运行时会为您处理所有这些，从外部来看，一切都像往常一样继续工作，只是使用更少的内存。
 这是有效的，因为读取这些结构的代码都在运行时中，并且同时更新。
 坚持使用这些 API 非常重要，因为任何试图直接访问这些数据结构的代码都将在今年的操作系统版本中停止工作，因为事情已经发生了变化，并且这些代码不会知道新的布局。
  我们看到了一些由于这些更改而损坏的真实代码，除了您自己的代码之外，还要注意您可能带入应用程序的外部依赖项，这些依赖项可能会在您没有意识到的情况下挖掘这些数据结构。
 这些结构中的所有信息都可以通过官方 API 获得。
  有像 class_getName 和 class_getSuperclass 这样的函数。
  当您使用这些 API 访问这些信息时，您知道无论我们在幕后进行什么更改，它们都会继续工作。
  所有这些 API 都可以在开发人员的 Objective-C 运行时文档中找到。
 苹果。
 com。
 接下来，让我们更深入地研究这些类数据结构，看看另一个变化，相对方法列表。
 每个类都有一个附加的方法列表。
  当您在类上编写新方法时，它会被添加到列表中。
  运行时使用这些列表来解析消息发送。
 每个方法包含三个信息。
 首先是方法的名称或选择器。
  选择器是字符串，但它们是唯一的，因此可以使用指针相等进行比较。
 接下来是方法的类型编码。
  这是一个表示参数和返回类型的字符串，它不用于发送消息，但它是运行时自省和消息转发等所需的。
 最后，有一个指向方法实现的指针。
  方法的实际代码。
  当您编写一个方法时，它会被编译成一个包含您的实现的 C 函数，然后方法列表中的条目指向该函数。
  让我们看一个单一的方法。
  我选择了 init 方法。
  它包含方法名称、类型和实现的条目。
 方法列表中的每一条数据都是一个指针。
  在我们的 64 位系统上，这意味着每个方法表条目占用 24 个字节。
 现在这是干净的内存，但干净的内存不是免费的。
  它仍然必须从磁盘加载并在使用时占用内存。
 现在这是一个进程中内存的缩小视图。
  请注意，它不是按比例缩放的。
  有这么大的地址空间需要 64 位来寻址。
  在该地址空间内，为堆栈、堆以及加载到进程中的可执行文件和库或二进制映像划分了各种部分，此处以蓝色显示。
 让我们放大并查看这些二进制图像之一。
 在这里，我们展示了指向其二进制文件位置的三个方法表条目。
  这向我们展示了另一个成本。
  二进制映像可以加载到内存中的任何位置，具体取决于动态链接器决定将其放置的位置。
 这意味着链接器需要将指针解析到图像中，并在加载时修复它们以指向它们在内存中的实际位置，这也有成本。
  现在请注意，二进制文件中的类方法条目仅指向该二进制文件中的方法实现。
  没有办法制作一种方法，它的元数据在一个二进制文件中，而代码在另一个二进制文件中实现。
 这意味着方法列表条目实际上不需要能够引用整个 64 位地址空间。
 他们只需要能够在他们自己的二进制文件中引用函数，而且这些函数总是在附近。
 因此，它们可以使用二进制文件中的 32 位相对偏移量，而不是绝对的 64 位地址。
  这是我们今年所做的改变。
  这有几个优点。
 首先，无论图像从何处加载到内存中，偏移量始终相同，因此它们从磁盘加载后不必进行修复。
 并且因为它们不需要被修复，它们可以保存在真正的只读存储器中，这样更安全。
 而且，当然，32 位偏移意味着我们将 64 位平台上所需的内存量减少了一半。
  我们已经在典型的 iPhone 上测量了系统范围内大约 80MB 的这些方法。
  由于它们只有一半大小，因此我们节省了 40 兆字节。
  这是您的应用可以用来取悦用户的更多内存。
 但是调酒呢？ 二进制文件中的方法列表现在不能引用完整的地址空间，但是如果你混合一个方法，它可以在任何地方实现。
  此外，我们刚刚说过我们希望保持这些方法列表只读。
 为了解决这个问题，我们还有一个全局表映射方法到它们的 swizzled 实现。
 调酒是罕见的。
  绝大多数方法实际上从未被混淆，所以这个表最终不会变得很大。
 更好的是，桌子很紧凑。
  内存一次被弄脏一页。
  使用旧样式的方法列表，调配一个方法会弄脏它所在的整个页面，从而导致单个调配产生数千字节的脏内存。
 有了桌子，我们只需支付额外的桌子条目的费用。
  与往常一样，这些变化对您来说是不可见的，一切都像往常一样继续工作。
  今年晚些时候推出的新操作系统版本支持这些相关方法列表。
 当您使用相应的最小部署目标进行构建时，这些工具将自动在您的二进制文件中生成相关方法列表。
 如果您仍然需要针对较旧的操作系统版本，请不要担心。
  Xcode 也会生成旧样式的方法列表格式，该格式仍然完全受支持。
  您仍然可以从使用新的相关方法列表构建的操作系统本身中受益，并且系统在同一应用程序中同时使用两种格式时没有问题。
 不过，如果您可以针对今年的操作系统版本，您将获得更小的二进制文件和更少的内存使用量。
 这在 Objective-C 或 Swift 中通常是一个很好的技巧。
 最低部署目标不仅仅是关于您可以使用哪些 SDK API。
  当 Xcode 知道它不需要支持旧的操作系统版本时，它通常可以发出更好的优化代码或数据。
 我们知道你们中的许多人需要支持较旧的操作系统版本，但这就是为什么尽可能增加部署目标是个好主意的原因。
 现在，需要注意的一件事是使用比您打算以 Xcode 为目标的目标更新的部署目标进行构建，通常可以防止这种情况发生，但它可能会漏掉，特别是如果您在其他地方构建自己的库或框架，然后将 他们在。
 在较旧的操作系统上运行时，较旧的运行时会看到这些相关方法，但它对它们一无所知，因此它会尝试像旧式基于指针的方法一样解释它们。
 这意味着它将尝试读取一对 32 位字段作为 64 位指针。
 结果是两个整数被粘在一起作为一个指针，这是一个无意义的值，如果实际使用它肯定会崩溃。
 您可以通过运行时读取方法信息中的崩溃来识别何时发生这种情况，其中错误指针看起来像两个 32 位值，如本例所示。
 如果您正在运行挖掘这些结构以读取值的代码，那么该代码将与这些旧的运行时存在相同的问题，并且当用户升级他们的设备时，应用程序会崩溃。
 所以再说一遍，不要那样做。
  使用 API。
  无论底层如何变化，这些 API 都会继续工作。
  例如，有一些函数，给定一个方法指针，返回其字段的值。
 让我们探索今年即将发生的另一项变化。
  arm64 上标记指针格式的更改。
 首先，我们需要知道什么是标记指针。
  我们会在这里变得非常低级，但别担心。
  就像我们讨论过的所有其他事情一样，您不需要知道这一点。
  这很有趣，也许可以帮助您更好地了解内存使用情况。
 让我们从普通对象指针的结构开始。
  通常，当我们看到这些时，它们被打印为这些大的十六进制数字。
  我们早些时候看到了其中的一些。
 让我们把它分解成二进制表示。
 我们有 64 位，但是，我们并没有真正使用所有这些位。
 只有中间的这些位才被设置在一个真实的对象指针中。
 由于对齐要求，低位始终为零。
  对象必须始终位于指针大小倍数的地址处。
 由于地址空间有限，高位始终为零。
  我们实际上并没有一直走到两个到 64。
 这些高位和低位始终为零。
 因此，让我们从这些位中选择一个始终为零的位并将其设为 1。
 这可以立即告诉我们这不是一个真正的对象指针，然后我们可以为所有其他位分配一些其他含义。
  我们称之为标记指针。
 例如，我们可能会在其他位中填充一个数值。
  只要我们教 NSNumber 如何读取这些位，并教运行时适当地处理标记指针，系统的其余部分就可以像对待对象指针一样对待这些东西，而永远不会知道它们之间的区别。
 这为我们节省了为每个这样的情况分配一个小数字对象的开销，这可能是一个重大的胜利。
 顺便说一句，这些值实际上是通过将它们与在进程启动时初始化的随机值组合来混淆的。
 这是一种安全措施，使伪造标记指针变得困难。
 在接下来的讨论中我们将忽略这一点，因为它只是顶部的一个额外层。
  请注意，如果您真的尝试查看内存中的这些值，它们会被打乱。
  因此，这是 Intel 上标记指针的完整格式。低位设置为 1 表示这是一个标记指针。
  正如我们所讨论的，对于真正的指针，该位必须始终为零，因此我们可以将它们区分开来。
 接下来的三位是标签号。
  这表示标记指针的类型。
  例如，3 表示它是一个 NSNumber，一个 6 表示它是一个 NSDate。
 因为我们有三个标签位，所以有八种可能的标签类型。
 其余的位是有效载荷。
  这是特定类型可以随意使用的数据。
 对于标记的 NSNumber，这是实际数字。
 现在，标签七有一个特殊情况。
  这表示扩展标签。
  扩展标签使用接下来的 8 位对类型进行编码，以较小的有效载荷为代价允许更多 256 种标签类型。
 这允许我们将标记指针用于更多类型，只要它们可以将它们的数据放入更小的空间中。
 这用于标记 UI 颜色或 NSIndexSets 之类的东西。
 现在，如果这对您来说真的很方便，那么听到只有运行时维护者（即 Apple）可以添加标记指针类型时，您可能会感到失望。
  但是如果你是一名 Swift 程序员，你会很高兴知道你可以创建自己的标记指针类型。
  如果您曾经使用过带有类的关联值的枚举，那么它就像一个标记指针。
  Swift 运行时将枚举鉴别器存储在相关值有效负载的备用位中。
 更重要的是，Swift 对值类型的使用实际上使标记指针变得不那么重要，因为值不再需要精确的指针大小。
 例如，Swift UUID 类型可以是两个单词并保持内联，而不是分配一个单独的对象，因为它不适合指针。
  现在这是在英特尔上标记的指针。
  让我们来看看ARM。
 在 arm64 上，我们已经扭转了局面。
  而不是底部位，顶部位设置为 1 以指示标记指针。
 然后标签号出现在接下来的三位中，然后有效载荷使用剩余的位。
  为什么我们在 ARM 上使用最高位来指示标记指针，而不是像我们在 Intel 上那样使用最低位？ 嗯，这实际上是对 objc_msgSend 的一个微小优化。
 我们希望 msgSend 中最常用的路径尽可能快，最常用的路径是普通指针。
  我们有两种不太常见的情况：标记指针和 nil。
 事实证明，当我们使用最高位时，我们可以通过一次比较来检查这两个，并且与分别检查 nil 和标记指针相比，这为 msgSend 中的常见情况节省了条件分支。
 就像在 Intel 中一样，我们有一个标签 7 的特殊情况，接下来的 8 位用作扩展标签，然后剩余的位用作有效载荷。
 或者这实际上是 iOS 13 中使用的旧格式。
  在今年的版本中，我们正在稍微调整一下。
  标记位保持在顶部，因为 msgSend 优化仍然非常有用。
 标签编号现在移动到底部的三位。
  扩展标签（如果使用）占据标签位之后的高八位。
 我们为什么这样做？ 好吧，让我们再次考虑一个普通的指针。
 我们现有的工具，如动态链接器，由于 ARM 功能称为 Top Byte Ignore，忽略指针的前八位，我们将扩展标签放在 Top Byte Ignore 位中。
 对于对齐的指针，底部的三位始终为零，但我们可以通过向指针添加一个小数字来解决这个问题。
  我们将添加 7 以将低位设置为 1。
  请记住，七表示这是一个扩展标签。
 这意味着我们实际上可以将上面的这个指针放入一个扩展的标签指针负载中。
 结果是一个带标记的指针，在其有效负载中带有一个普通指针。
  为什么有用？ 嗯，它开启了标记指针指向二进制文件中常量数据的能力，例如字符串或其他数据结构，否则它们将不得不占用脏内存。
 现在，当然，这些更改意味着直接访问这些位的代码在今年晚些时候发布 iOS 14 时将不再有效。
 像这样的逐位检查在过去是可行的，但它会在未来的操作系统上为您提供错误的答案，并且您的应用程序将开始神秘地破坏用户数据。
 所以，不要使用依赖于我们刚刚谈到的任何东西的代码。
  相反，您可能会猜到我要说的是使用 API。
 像 isKindOfClass 这样的类型检查适用于旧的标记指针格式，它们将继续适用于新的标记指针格式。
  所有 NSString 或 NSNumber 方法都继续工作。
  这些标记指针中的所有信息都可以通过标准 API 检索。
 值得注意的是，这也适用于 CF 类型。
 我们不想隐藏任何东西，我们绝对不想破坏任何人的应用程序。
  当这些细节没有公开时，只是因为我们需要保持灵活性来进行这样的更改，只要它们不依赖于这些内部细节，您的应用就会继续正常工作。
 所以，让我们结束吧。
  在本次演讲中，我们看到了一些幕后改进，这些改进减少了我们的运行时开销，为您和您的用户留下了更多可用内存。
 您无需做任何事情即可获得这些改进，除非考虑提高您的部署目标。
 为了帮助我们每年进行这些改进，只需遵循一个简单的规则。
  不要直接读取内部位。
  使用 API。
  感谢观看，并享受您更快的设备。
